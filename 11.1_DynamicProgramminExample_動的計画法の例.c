/* 動的計画法　 */

/*

長さnの数列Aと整数mに対して、Aの要素の中のいくつかの要素を足し合わせて、
mが作れるかどうかを判定するプログラムを作成してください。Aの要素はただ一つだけ用いることができる

入力:
    1> 数列Aの個数n
    n> 数列Aの整数群
    n+1> m

出力:
    1> mを作ることができればYESを出力

*/

//////////////////////////////前処理/////////////////////////////////////////


#include<stdio.h>

#define M 1000 //メモリストの上限
#define NG -1  //mの生成失敗
#define OK -2  //mの生成成功

int n ,A[50];
int dp[M][M]  //論理演算の結果 or 数字を

//////////////////////////////全探索/////////////////////////////////////////

/* メモ化しながら問題を解いていく*/
int solve(int i,int m){
  if (dp[i][m] == OK){dp[i][m] = OK;}                  //既に計算済みだった場合
  else if (m == 0){dp[i][m] = OK;}                     //m=0の時
  else if (solve(i+1,m) == OK){dp[i][m] = OK;}         //Aの次のリストからスタート
  else if (solve(i+1,m - A[i]) == OK){dp[i][m] = OK;}  //m-A[i]をして次のリストからスタート
  else{dp == NG;}

  return dp[i][m]
  }

//////////////////////////////メイン関数//////////////////////////////////////

int main(){
  int  M; //Aのリストで実現できるか検討される数:M
  printf("検討するAのリスト数を入力\n");
  scanf("%d",&n);               
  for(int i = 0; i<n; i++){
    printf("Aのリスト　%d　個目",i);
    scanf("%d",&A[i]);
    }

  printf("検討される数:Mを入力\n");  
  scanf("%d",&M);
  if(solve(0,M) == OK){printf("YES!\n");}else{printf("NO..\n");} //A[0]からスタート

  return 0;
}

//うまく作動していない模様。。。

/* 
再帰関数の中で二つの再帰関数をn回呼び出しているので、O(mn)のアルゴリズムになる 
＞再帰の際に一度計算した組み合わせを際計算する必要がなくなるため、一度計算した値は保存される。
よって<m＊n>で計算できる。
*/