/* フィボナッチ数列 */

/*

フィボナッチ数列の第n項を出力するプログラム

入力:
    1　> １つの整数n
出力:
    1　> フィボナッチ数列のn項
*/

/*/////////////////////////////前処理////////////////////////////////////////*/

#include<stdio.h>

#define MAX 1000    //メモリ格納の最大値を定義している
int F[MAX]={0}      //計算結果を格納するメモリ

/*/////////////////////////////全探索////////////////////////////////////////*/

//再帰的に解く
int fib_Re(int n){
    if (n == 0 || n == 1){return 1}
    return fib_Re(n-2) + fib_Re(n-1)
}

//動的計画法で解く
int fib_Dy(int n){
    if(n == 0 || n == 1){return F[n] = 1}
    if(F[n] != 0){return F[n]}
    return F[n] = fib_Dy(n-1) + fib_Dy(n-2)
}

/*/////////////////////////////メイン関数/////////////////////////////////////*/

int main(){
  int  M; //Aのリストで実現できるか検討される数:M
  printf("検討するAのリスト数を入力\n");
  scanf("%d",&n);               
  for(int i = 0; i<n; i++){
    printf("Aのリスト　%d　個目",i);
    scanf("%d",&A[i]);
    }

  printf("検討される数:Mを入力\n");  
  scanf("%d",&M);
  if(solve(0,M) == OK){printf("YES!\n");}else{printf("NO..\n");} //A[0]からスタート

  return 0;
}

//うまく作動していない模様。。。

/*/////////////////////////////考察/////////////////////////////////////*/

//  再帰関数の中で二つの再帰関数をn回呼び出しているので、O(n)のアルゴリズムになる 
//  ＞再帰の際に一度計算した組み合わせを際計算する必要がなくなるため、一度計算した値は保存される。
//  よって<n>で計算できる。
