//深さ優先探索(DFS)

/*
探索は元の視点から到達可能な全ての頂点を発見するまで続き、未発見の頂点が残っていれば、
その中の番号が一番小さい一つを新たな始点として探索を続けます。

    ＞d[v]:vを最初に訪問した発見時刻を記録
    ＞f[v]:vの隣接リストを調べ終えた完了時刻を記録

有向グラフG=(V,E)に対する深さ優先探索の動作を示すプログラムを作成：

    ＞Gは隣接リスト表現の形式で与えられる。各頂点には１からnまでの番号がふられる
    ＞各隣接リストの頂点は番号が小さい順に並べられる。
    ＞プログラムは各頂点の発見時刻と完了時刻を報告
    ＞深さ優先探索の過程において、訪問する頂点の候補が複数ある場合は頂点番号が小さいものから選択
    ＞最初に訪問する頂点の開始時刻を１とします

入力:
    1＞Gの頂点数n
    n＞n行で u(頂点番号) k(次数)v1-vk(uに隣接する頂点の番号)

出力:
    1＞各頂点については、id,d(最初の発見時刻),f(隣接リストを調べ終えた鑑賞時刻)を空白区切で出力。頂点の番号順で出力

実装方法
    １＞スタックによる深さ優先探索
    ２＞再帰による深さ優先探索

*/

//////////////////////////////前処理/////////////////////////////////////////


#include<stdio.h> //入出力モジュール

#define N 100       //隣接リストのセルの数
#define None 0
#define WHITE 0     //未訪問
#define GRAY 1      //最初に訪問 
#define BLACK 2     //隣接リストも調べ終えた。

int n, M[N][N];  //隣接行列(グローバル変数)
int color[N], d[N], f[N], tt; //color:色、d[N]:訪問時刻、f[N]:探索終了時刻(グローバル変数) tt:現在時間

//////////////////////////再帰による幅優先探索/////////////////////////////////

void dfs_visit(int u){
    color[u] = GRAY;                //最初の訪問時間を記録
    d[u] = ++tt;                    //最初の訪問としてのグローバル変数を記録
    for(int v = 0; v < n; v++){     //接点番号:uの全ての隣接点に対して
        if(M[u][v] == 0)continue;   //すべての隣接リストに対して、未訪問かつ、パスが通っていたら再帰する
        if(color[v] == WHITE){      //M[u][v] == 1 を満たして
            dfs_visit(v);
        }
    }
    color[u] == BLACK;              //すべての子どもを探索し終えたら探索済みとする
    f[u] = ++tt;                    //グローバル変数を記録
}


void dfs(){
    for(int u = 0; u < n; u++){color[u] = WHITE;} //0 - u-1 までWHITE(初期化)
    tt = 0;                                       //時間も初期化

    for(int u = 0; u < n; u++){
        if(color[u] == WHITE)dfs_visit(u);        //未訪問のuを始点として深さ優先探索
    }
}


////////////////////////////メイン関数////////////////////////////////////////
int main(){
    int u, v, k, i, j;

    scanf("%d",&n);
    for(i = 0; i < n; i++){for(j = 0; j < n; j++ )M[i][j] = None;} //隣接行列の初期化

    for (i = 0; i < n; i++){
        scanf("%d %d",&u ,&k ); //u:節点の番号 k:隣接する接点の個数（次数）
        u --; //0オリジン化
        for (j = 0; j < k; j++ ){
            scanf("%d", &v);
            v--; //0オリジン化
            M[u][v] = 1 //隣接行列の値を変える
        }
    }
    dfs();

    return 0;
}


//計算時間　＞　すべての頂点に対して、隣接しているかを調べるので、O(v^2)のアルゴリズム