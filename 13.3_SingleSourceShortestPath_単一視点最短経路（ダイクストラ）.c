/*　単一視点最短経路(ダイクストラのアルゴリズム)　*/

/*

与えられた重み付き有向グラフG=(V,E)について、単一視点最短経路のコストを求めるプログラムを作成する。Gの頂点0を始点とし、
0から頂点vについて、最短経路上の辺の重みの総和d[v]を出力してください。

入力:
最初の行に、Gの頂点数nが与えられる。
続くn行に、各頂点uの隣接リストが以下の形式で一行に与えられる。
<u k v1 c1 v2 c2>
u は頂点の番号、kはuの出次数、vはuに隣接する頂点の番号であり、cは有効辺の重み。

出力:
各頂点番号vと距離d[v]を一つの空白区切で順番に出力する
*/

//////////////////////////////　前処理　/////////////////////////////////////////
#include<stdio.h>

#define MAX 100
#define INFTY (1<<21) //最大値を定義しておく
#define WHITE 0
#define GRAY 1
#define BLACK 2

int n,M[MAX][MAX]; //隣接リストの作成

//////////////////////////////　ダイクストラのアルゴリズム　/////////////////////////////////////////
void dijkstra(){
    int minv, v;
    int d[MAX], color[MAX];      //頂点のdistance,頂点の状態

    for(int i = 0 ; i < n ; i++){
        d[i] = INFTY;            //すべての距離を最長に設定しておく
        color[i] = WHITE;        //すべての探索状況を未探索にする
    }

    d[0] = 0;                    //出発点の距離は０
    color[0] = GRAY;
    while(1){
        minv = INFTY;                                   //最小距離を初期化
        int u = -1;                                     //未探索済の頂点を探す。
        for(int i = 0 ; i < n ; i++){                   //すべての未探索頂点に関して
            if( minv > d[i] && color[i] != BLACK){      //最小距離の値を更新し続ける。
                u = i;                                  //親になる次数を決定する
                minv = d[i];                            //最短距離minvは親となる頂点の値(d[v])
            }
        }
        if(u == -1){break;}                             //BLACK以外ない時点で、全探索終了
        color[u] = BLACK;                               //親を探索済みにする
        for ( v = 0; v < n; v++){                       //すべての頂点に関して
            if(color[v] !=BLACK && M[u][v] != INFTY ){  //パスが通っている、かつ、探索済みでなければ
                if(d[v] > d[u] + M[u][v]){              //最短経路を短縮できれば
                    d[v] = d[u] + M[u][v];              //最短経路の入れ替えを行う。
                    color[v] = GRAY;                    //隣接する節点を探索中にする
                }
            }
        }
    }
    for(int i = 0 ; i < n ; i++){
        printf("頂点番号:%d 距離:%d\n",i,d[i]);
    }
}
//////////////////////////////　メイン関数　/////////////////////////////////////////
int main(){
    int i,j,u,k,v,c,n;
    printf("頂点の数は？\n");
    scanf("%d",&n);
    for(i = 0; i<n; i++){
        for(j = 0; j<n; j++){
            M[i][j] = INFTY;
            }
        }

    for(i = 0 ; i < n ; i++){
        printf("頂点の番号は？\n");
        scanf("%d",&u);
        printf("uの出次数？\n");
        scanf("%d",&k);
        for(j = 0 ; j < k ; j++){
            printf("隣接する頂点の番号は？\n");
            scanf("%d",&v);
            printf("隣接する頂点の有効辺の重みは？\n");
            scanf("%d",&c);
            }
        }
    dijkstra();

    return 0;
}


//計算時間　＞　O(V^2)のアルゴリズム
