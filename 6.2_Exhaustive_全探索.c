/* ExhaustiveSearch_全探索 */

/*

長さnの数列Aと整数mに対して、Aの要素の中のいくつかの要素を足し合わせて、
mが作れるかどうかを判定するプログラムを作成してください。Aの要素はただ一つだけ用いることができる

入力:
    1> 数列Aの個数n
    n> 数列Aの整数群
    n+1> m

出力:
    1> mを作ることができればYESを出力

*/

////////////////////////////////////////////////////////////////////////////
//////////////////////////////前処理/////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

#include<stdio.h>

int n ,A[50];

////////////////////////////////////////////////////////////////////////////
//////////////////////////////全探索/////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

int solve(int i,int m){
  if(m == 0){return 1;}     //mが0だったら:成功　→　最上位まで返って"True"を返す
  if(i >= n){return 0;}     //検討するリストの番号が上限を超えたら:失敗

  //次の要素スタートの場合と今の要素を引いた上で、次の要素をスタートさせた場合、
  //再帰的に論理関数の結果が帰って来る。
  int  res = solve(i+1 ,m) || solve(i+1, m - A[i]); //どちらかがTrueで返ってきたら（OR）
  return  res; //最後層のどこかで1がかえれば１になる。
}

////////////////////////////////////////////////////////////////////////////
//////////////////////////////メイン関数//////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

int main(){
  int  M; //Aのリストで実現できるか検討される数:M
  printf("検討するAのリスト数を入力\n");
  scanf("%d",&n);               
  for(int i = 0; i<n; i++){
    printf("Aのリスト　%d　個目",i);
    scanf("%d",&A[i]);
    }

  printf("検討される数:Mを入力\n");  
  scanf("%d",&M);
  if(solve(0,M)){printf("YES!\n");}else{printf("NO..\n");} //A[0]からスタート

  return 0;
}

//うまく作動していない模様。。。

/* 再帰関数の中で二つの再帰関数をn回呼び出しているので、O(2^n)のアルゴリズムになる */