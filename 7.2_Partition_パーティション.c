/* Partition(パーティション) */

/*

n個の整数を含む数列Sをを読み込み、A[r]を基準として、配列を分割する。
mergeにおける比較回数の総数を報告

入力:
    1　>　Aの長さを表す整数n
    2　>　S[]を表すn個の整数

出力:
    1　>　分割された整数を一行に出力
*/


/*//////////////////////////////前処理/////////////////////////////////////////*/

#include<stdio.h>
#define MAX 100000

int A[MAX], n;

/*//////////////////////////////パーテーション/////////////////////////////////////////*/

int partition(int p, int r){      //p:パーテーションの位置（初期値:0 |● ● ● ）r:閾値
    int x,i,t;
    x = A[r];                     //閾値を設定
    i = p - 1;                    //
    for(int j = p; j < r; j++){   //j=0 評価する全ての値に関して
      if(A[j] <= x ){             //A[j]の要素がx( = A[r])より小さい時
        i++;                      //iの初期値-1 =A[-1]=A[x]=x
        t=A[i];A[i]=A[j];A[j]=t;  // iより左側にやられる。
      }
    }
    t = A[i+1];A[i+1]=A[r];A[r]=t; //最後にiの一個右側（境界部分と一番右A[r]を交換する）
    return i + 1;
}

/*//////////////////////////////メイン関数/////////////////////////////////////////*/

int main(){

  scanf("%d", &n);
  for(int i = 0; i < n ;i++)scanf("%d",&A[i]);

  int q = partition(0,n-1);               //数列の最後の行をパーテーションとする。
  for(int i=0;i<n;i++){
    if(i)printf(" ");
    if(i == q)printf("[");
    printf("%d",A[i]);
    if(i == q)printf("]");
  }

  return 0;
}

/*/////////////////////////////考察/////////////////////////////////////*/

//  パーテーションの前後に移動するかの問題なので、最大O(n)のアルゴリズムになる。
